---
id: modular
title: 'Modular Arithmetic'
author: Darren Yao, Michael Cao, Andi Qu, Benjamin Qi, Andrew Wang
prerequisites:
  - divis
description: Working with remainders from division.
frequency: 2
---

<!-- <Resource source="CF" title="CodeNCode - Number Theory Course" url="77137">lots of advanced stuff you don't need to know at this level</Resource>
   -->

<Resources>
	<Resource source="IUSACO" title="13.3 - Modular Arithmetic">
		very brief, module is based off this
	</Resource>
	<Resource
		source="David Altizio"
		title="Modular Arithmetic"
		url="https://davidaltizio.web.illinois.edu/ModularArithmetic.pdf"
		starred
	>
		plenty of examples from math contests
	</Resource>
	<Resource source="CPH" title="21.2 - Modular Arithmetic" starred />
	<Resource source="PAPS" title="16.4 - Modular Arithmetic" />
	<Resource
		source="CF"
		title="Spheniscine - Modular Arithmetic for Beginners"
		url="https://codeforces.com/blog/entry/72527"
	>
		some practice probs
	</Resource>
	<Resource
		source="MONT@Modern Olympiad Number Theory"
		title="2, 5 - Modular Arithmetic"
		url="https://artofproblemsolving.com/community/c6h2344755"
		starred
	 />
</Resources>

## Introduction

<!-- Some silver problems involve $10^9+7$, should this be introduced in silver? -->

In **modular arithmetic**, instead of working with integers themselves, we work
with their remainders when divided by $m$. We call this taking modulo $m$. For
example, if we take $m = 23$, then instead of working with $x = 247$, we use
$x \bmod 23 = 17$. Usually, $m$ will be a large prime, given in the problem; the
two most common values are $10^9 + 7$ and $998\,244\,353=119\cdot 2^{23}+1$.
Modular arithmetic is used to avoid dealing with numbers that overflow built-in
data types, because we can take remainders, according to the following formulas:

$$
(a+b) \bmod m = (a \bmod m + b \bmod m) \bmod m
$$

$$
(a-b) \bmod m = (a \bmod m - b \bmod m) \bmod m
$$

$$
(a \cdot b) \pmod{m} = ((a \bmod m) \cdot (b \bmod m)) \bmod m
$$

$$
a^b \bmod {m} = (a \bmod m)^b \bmod m
$$

## Modular Exponentiation

<FocusProblem problem="expo" />

### Resources

<Resources>
	<Resource
		source="cp-algo"
		title="Binary Exponentiation"
		url="algebra/binary-exp.html"
	/>
</Resources>

**Binary exponentiation** can be used to efficently compute $x ^ n \mod m$. To
do this, let's break down $x ^ n$ into binary components. For example,
$5 ^ {10}$ = $5 ^ {1010_2}$ = $5 ^ 8 \cdot 5 ^ 2$. Then, if we know $x ^ y$ for
all $y$ which are powers of two ($x ^ 1$, $x ^ 2$, $x ^ 4$, $\dots$ ,
$x ^ {2^{\lfloor{\log_2n} \rfloor}}$, we can compute $x ^ n$ in
$\mathcal{O}(\log n)$.

To deal with $m$, observe that modulo doesn't affect multiplications, so we can
directly implement the above "binary exponentiation" algorithm while adding a
line to take results $\pmod m$.

<!--
Finally, since $x ^ y$ for some $y \neq 1$ equals $x ^ {y - 1}$, and $x$ otherwise, we can compute these sums efficently.  -->

### Solution - Exponentiation

<Spoiler title="Solution">

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

ll binpow(ll x, ll n, ll m) {
	assert(n >= 0);
	x %= m; //note: m*m must be less than 2^63 to avoid ll overflow
	ll res = 1;
	while (n > 0) {
		if (n % 2 == 1) //if n is odd
			res = res * x % m;
		x = x * x % m;
		n /= 2; //divide by two
	}
	return res;
}

int main() {
	int TC; cin >> TC;
	for (int i = 0; i < TC; ++i) {
		int a, b; cin >> a >> b;
		cout << binpow(a,b,1e9+7) << "\n";
	}
}
```

</CPPSection>

<JavaSection>

```java

import java.io.*;
import java.util.*;

public class Exponentation
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(System.out);
		int n = Integer.parseInt(br.readLine());
		for (int i = 0; i < n; i++){
			StringTokenizer st = new StringTokenizer(br.readLine());
			long a = Long.parseLong(st.nextToken());
			long b = Long.parseLong(st.nextToken());
			out.println(binpow(a, b, (long)1e9+7));
		}
		out.close();
	}
	public static long binpow(long x, long n, long m) {
		assert(n >= 0);
		x %= m; //note: m*m must be less than 2^63 to avoid ll overflow
		long res = 1;
		while (n > 0) {
			if (n % 2 == 1) //if n is odd
				res = res * x % m;
			x = x * x % m;
			n /= 2; //divide by two
		}
		return res;
	}
}


```

</JavaSection>

</LanguageSection>

</Spoiler>

## Modular Inverse

<FocusProblem problem="binomial" />

<Resources>
	<Resource
		source="cp-algo"
		title="Modular Multiplicative Inverse"
		url="algebra/module-inverse.html"
		starred
	>
		Various ways to take modular inverse, we'll only discuss the second here
	</Resource>
</Resources>

The **modular inverse** is the equivalent of the reciprocal in real-number
arithmetic; to divide $a$ by $b$, multiply $a$ by the modular inverse of $b$.
We'll only consider prime moduli $p$ here.

For example, $i$, the modular inverse of $2$ where $p=10^9+7$ is 
$$
1\equiv p+1 \pmod{p}.
$$

$$
2\cdot i\equiv p+1 \pmod{p}.
$$

$$
i=\frac{p+1}{2}=5\cdot 10^8+4
$$

where $i$ is the modular inverse. This means that for any integer $x$,

$$
(2x)\cdot i\equiv x\cdot (2i)\equiv x\pmod{10^9+7}.
$$

For example, $10i\equiv 5\pmod{10^9+7}$.



### With Exponentiation

[**Fermat's Little Theorem**](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)
(not to be confused with Fermat's **Last** Theorem) states that all integers $a$
not divisible by $p$ satisfy $a^{p - 1} \equiv 1 \pmod{p}$. Consequently,
$a^{p-2} \cdot a \equiv 1 \pmod{p}$. Therefore, $a^{p - 2}$ is a modular inverse
of $a$ modulo $p$.

<LanguageSection>

<CPPSection>

```cpp
int main() {
	ll m = 1e9+7;
	ll x = binpow(2,m-2,m);
	cout << x << "\n"; // 500000004
	assert(2*x%m == 1);
}
```

</CPPSection>

<JavaSection>

```java


public class main
{
   public static void main(String[] args) throws IOException
   {
	long m = (long)1e9+7;
	long x = binpow(2,m-2,m);
	System.out.println(x); // 500000004
	assert(2*x%m == 1);
   }
}

```

</JavaSection>

</LanguageSection>

### Solution - Binomial Coefficients $\mathcal{O}(N \log N)$

In order to calculate $a \choose b$, we can precalculate the factorials to speed up the calculation of $a!$, $b!$, and $(a-b)!$. $a \choose b$ is equivalent to

$$
\frac{a!}{b!(a-b)!} = a! \cdot b!^{-1} \cdot (a-b)!^{-1}.
$$

Thus, calculating the inverses of $b!$ and $(a-b)!$ is sufficient in finding $a \choose b$.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
const int MOD = (int)1e9+7;
 
ll inverse(ll num){
    ll a = num; ll b = MOD-2;
    //equivalent to num^(MOD-2)
    ll res = 1;
    while (b > 0) {
        if (b % 2 == 1)
            res = res * a % MOD;
        a = a * a % MOD;
        b /= 2;
    }
    return res;
}
 
int main() {
    cin.tie(0)->sync_with_stdio(0);
    ll factorial[1000001];
    factorial[0] = factorial[1] =1;
    for (int i = 2; i<=1000000; i++) {
        factorial[i]=(factorial[i-1]*i)%MOD;
    }
 
    ll n, a, b;
    cin >> n;
    for(int i = 0; i < n; i++) {
        cin >> a >> b;
        ll ans = (factorial[a] * inverse(factorial[b])) % MOD;
        ans *= inverse(factorial[a-b]);
        ans %= MOD;
        cout << ans << "\n";
    }
}
```

</CPPSection>

</LanguageSection>

### Solution - Binomial Coefficients $\mathcal{O}(N)$

Because it takes $\mathcal{O}(\log p)$ time to compute a modular inverse modulo
$p$, frequent use of division inside a loop can significantly increase the
running time of a program. If the modular inverse of the same number(s) is/are
being used many times, it is a good idea to precalculate it. Note the above problem could also be solved by precalculating invererses. First find the inverse of $N!$ for a large $N$, then calculate the inverses of $1...{N!-1}$ by multiplying each inverse starting from $N!$ with their respective values in $\mathcal{O}(N)$.

Also, one must always ensure that they do not attempt to divide by 0. Be aware
that after applying modulo, a nonzero number can become zero, so be very careful
when dividing by non-constant values.

```cpp
#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
const int MOD = (int)1e9+7;
 
ll inverse(ll num){
    ll a = num; ll b = MOD-2;
    //equivalent to num^(MOD-2)
    ll res = 1;
    while (b > 0) {
        if (b % 2 == 1)
            res = res * a % MOD;
        a = a * a % MOD;
        b /= 2;
    }
    return res;
}
 
int main() {
    cin.tie(0)->sync_with_stdio(0);
    ll factorial[1000001], inverses[1000001];
    factorial[0] = factorial[1] =1;
    for (int i = 2; i<=1000000; i++) {
        factorial[i]=(factorial[i-1]*i)%MOD;
    }
	inverses[1000000] = inverse(factorial[1000000]);
	for(int i = 999999; i >= 0; i--){
		inverses[i] = (inverses[i+1]*(i+1)) % MOD;
	}
    ll n, a, b;
    cin >> n;
    for(int i = 0; i < n; i++) {
        cin >> a >> b;
        ll ans = (factorial[a] * inverses[b]) % MOD;
        ans *= inverses[a-b];
        ans %= MOD;
        cout << ans << "\n";
    }
}
```

<Optional title="Another Way to Compute Modular Inverses">

We can also use the extended Euclidean algorithm. See the module in the
[Advanced](/adv/extend-euclid) section.

</Optional>

## Templates

<Resources>
	<Resource
		source="Benq"
		title="ModInt"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/number-theory%20(11.1)/Modular%20Arithmetic/ModInt.h"
	/>
	<Resource
		source="Benq"
		title="ModIntShort"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/number-theory%20(11.1)/Modular%20Arithmetic/ModIntShort.h"
	>
		feasible to type up during a contest
	</Resource>
</Resources>

Using my template, both of these do the same thing:

```cpp
int main() {
	{
		int a = 1e8, b = 1e8, c = 1e8;
		cout << (ll)a*b%MOD*c%MOD << "\n"; // 49000000
	}
	{
		mi a = 1e8, b = 1e8, c = 1e8;
		// cout << a*b*c << "\n"; // doesn't work
		// ^ not silently converted to int
		cout << int(a*b*c) << "\n"; // 49000000
	}
}
```

## Problems

<Problems problems="general" />
